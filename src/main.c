/*
******************************************************************************
File:     main.c
Info:     Generated by Atollic TrueSTUDIO(R) 7.1.2   2017-10-24
******************************************************************************
*/

/* Includes */
//#include "stm32f4xx.h"
#include "stm32f401_discovery.h"
#include "main.h"

/* Private macro */
/* Private variables */


/**
**===========================================================================
**
**  Abstract: main program
**
**===========================================================================
*/
int main(void)
{

  /**
  *  IMPORTANT NOTE!
  *  The symbol VECT_TAB_SRAM needs to be defined when building the project
  *  if code has been located to RAM and interrupts are used. 
  *  Otherwise the interrupt table located in flash will be used.
  *  See also the <system_*.c> file and how the SystemInit() function updates 
  *  SCB->VTOR register.  
  *  E.g.  SCB->VTOR = 0x20000000;  
  */

  SystemInit();



  /* Initialize LEDs */
  STM_EVAL_LEDInit(LED3);
  STM_EVAL_LEDInit(LED4);
  STM_EVAL_LEDInit(LED5);
  STM_EVAL_LEDInit(LED6);



  //enable clocks
  initPeripheralClocks();

  //init the codec (done once at the start, not needed from here on out)
  codec_init();
  codec_ctrl_init();

  //enable the SPI peripheral in I2Sound Mode
  I2S_Cmd(CODEC_I2S, ENABLE);

  //set up the Finite Response Filter
  fir_8 filt;
  initFilter(&filt);


  while(sampleCounter < 96000){
	if (SPI_I2S_GetFlagStatus(CODEC_I2S, SPI_I2S_FLAG_TXE)){
	  SPI_I2S_SendData(CODEC_I2S, sample); //TODO: is the sample still 0 at this point?

      //only update on every second sample to insure that L & R ch. have the same sample value
	  if (sampleCounter & 0x00000001){
	    sawWave += NOTEFREQUENCY;
	    if (sawWave > 1.0){
	      sawWave -= 2.0;
	    }
	    filteredSaw = updateFilter(&filt, sawWave);
	    sample = (int16_t)(NOTEAMPLITUDE*filteredSaw);
	  }
	  sampleCounter++;
	}
  }

  //sit in a while loop sending silence
  while(1){
	  SPI_I2S_SendData(CODEC_I2S, 0); //TODO: is the sample still 0 at this point?
  }

  /* Infinite loop */
  while(1)
  {

//	//if the I2S flag is set (if it is, the Transmit buffer empty flag is set as we are checking the TXE flag)
//  	if (SPI_I2S_GetFlagStatus(CODEC_I2S, SPI_I2S_FLAG_TXE))
//  	{
//  		SPI_I2S_SendData(CODEC_I2S, sample); //TODO: is the sample still 0 at this point?
//
//  		//only update on every second sample to insure that L & R ch. have the same sample value
//  		if (sampleCounter & 0x00000001)
//  		{
//  			sawWave += NOTEFREQUENCY;
//  			if (sawWave > 1.0)
//  				sawWave -= 2.0;
//
//  			filteredSaw = updateFilter(&filt, sawWave);
//
//  			sample = (int16_t)(NOTEAMPLITUDE*filteredSaw);
//  			//sample = sawWave;
//  		}
//  		sampleCounter++;
//  	}
//
//  	if (sampleCounter==48000)
//  	{
//  		STM_EVAL_LEDOff(LED6);
//
//  	}
//  	else if (sampleCounter == 96000)
//  	{
//  		STM_EVAL_LEDOn(LED6);
//  		sampleCounter = 0;
//  	}

  }
}


// a very crude FIR lowpass filter
float updateFilter(fir_8* filt, float val)
{
	uint16_t valIndex;
	uint16_t paramIndex;
	float outval = 0.0;

	valIndex = filt->currIndex;
	filt->tabs[valIndex] = val;

	for (paramIndex=0; paramIndex<8; paramIndex++)
	{
		outval += (filt->params[paramIndex]) * (filt->tabs[(valIndex+paramIndex)&0x07]);
	}

	valIndex++;
	valIndex &= 0x07;

	filt->currIndex = valIndex;

	return outval;
}

void initFilter(fir_8* theFilter)
{
	uint8_t i;

	theFilter->currIndex = 0;

	for (i=0; i<8; i++){
		theFilter->tabs[i] = 0.0;
	}

	theFilter->params[0] = 0.01;
	theFilter->params[1] = 0.05;
	theFilter->params[2] = 0.12;
	theFilter->params[3] = 0.32;
	theFilter->params[4] = 0.32;
	theFilter->params[5] = 0.12;
	theFilter->params[6] = 0.05;
	theFilter->params[7] = 0.01;
}


void initPeripheralClocks(void){
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA | RCC_AHB1Periph_GPIOB |
						   RCC_AHB1Periph_GPIOC	| RCC_AHB1Periph_GPIOD, ENABLE);

	RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C1 | RCC_APB1Periph_SPI3, ENABLE);


}


/*
 * Callback used by stm32f401_discovery_audio_codec.c.
 * Refer to stm32f401_discovery_audio_codec.h for more info.
 */
void EVAL_AUDIO_TransferComplete_CallBack(uint32_t pBuffer, uint32_t Size){
  /* TODO, implement your code here */
  return;
}

/*
 * Callback used by stm32f401_discovery_audio_codec.c.
 * Refer to stm32f401_discovery_audio_codec.h for more info.
 */
uint16_t EVAL_AUDIO_GetSampleCallBack(void){
  /* TODO, implement your code here */
  return -1;
}
